use mavenmovies;


-- First Normal Form 1NF
-- Identify a table in the Sakila database that violates 1NFn Explain how you would normalize it to achieve 1NF
select * from actor_award;
-- the awards column contains multiple values in each cell. the cell do not have atomic values. there will be seperate of data for each of the awards e.g
-- '1', '12', 'KARL', 'BERRY', 'Emmy', '2006-02-15 04:34:33'
-- '1', '12', 'KARL', 'BERRY', ' Oscar', '2006-02-15 04:34:33'


-- Second Normal Form 2NF
-- Choose a table in Sakila and describe how you would determine whether it is in 2NF If it violates 2NF,
-- explain the steps to normalize it.

-- i have chosen a table customer. to check that the table is in in 2nf i have to ensure that there are no partial functional dependencies present i.e a part of candidate key shouldnt
-- identitify some data of other column. the the whole candidate key should do it not partial candidate key. 
-- to convert a table into 2nf , partial dependencies should be identified. a seperate table for the partial dependencies should be made and it should be connected with the orignal table
-- so that no data loss takes place

-- Third NoVmal FoVm 3NF
-- Identify a table in Sakila that violates 3NF Describe the transitive dependencies present and outline the
-- steps to normalize the table to 3NF

-- i couldnt find a table that voilates the 3nf



-- Normalization Process
-- Take a specific table in Sakila and guide through the process of normalizing it from the initial
-- unnormalized form up to at least 2NF 
select * from actor_Award;
-- the award column should have atomic values for each row we will create seperate rows related to each award after doing this the table will be in 1 nf
-- '1', '12', 'KARL', 'BERRY', 'Emmy', '2006-02-15 04:34:33'
-- '1', '12', 'KARL', 'BERRY', ' Oscar', '2006-02-15 04:34:33'

-- there partial dependency present in the table between the actor_id and the first_name, last_name 
-- there should be a seperate table present for the actor data which will consist of the actor_Id , first_name , last_name
-- and the orignal table will contail only the actor_id and the first and last name data should be removed from the table.



-- CTE Basics>
-- Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have
-- acted in from the actor and  film_Actor tables
with actor_N_film_c as (
select distinct(concat(actor.first_name,' ',actor.last_name)) as actor_name, count(film_Actor.film_id) as film_count from actor 
inner join film_Actor on actor.actor_id = film_Actor.actor_id group by film_Actor.actor_id
)
select * from actor_N_film_c;

-- RecuVsive CTE>
-- Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the cateogry
-- i was confused in this question and coudnt attempt because there was no sub category column present in the table 


-- Create a CTE that combines information from  the film and language tables to display the film title, language
-- name, and rental rate
with film_language as (
select film.title,language.name,film.rental_rate from film inner join language on film.language_id = language.language_id 
)
select * from film_language;

-- CTE foV AggVegation
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from
-- the customer and payment tables
with customer_Data as (select customer_id , first_name , last_name from customer),
payment_data as (select cd.customer_id, concat(cd.first_name ,' ',cd.last_name) as name , sum(payment.amount) as revenue from payment inner join 
customer_data cd on cd.customer_id = payment.customer_id group by  cd.customer_id, cd.first_name, cd.last_name)
select * from payment_Data;

-- CTE with Window Functions>
-- Utilize a CTE with a window function to rank films based on their rental duration from the film table
with rank_rental as (
select film.film_id , film.title, rank() over(order by rental_duration) as rank_ , film.rental_duration from film
)
select * from rank_Rental;


-- CTE and Filtering
-- Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer 
-- table to retrieve additional customer details
with c_ab2 as (
select customer_id , count(rental_id) as no_ from rental group by customer_id
),
c_detail as(
select customer.* , c_ab2.no_ from customer inner join c_Ab2 on c_ab2.customer_id = customer.customer_id where c_Ab2.no_ > 2
)
select * from c_detail;

-- CTE for Date Calculations
-- Write a query using a CTE to find the total number of rentals made each month, considering the rental_Date 
-- from the rental table
with m_count as (
select distinct monthname(rental_Date) as month_ , count(rental_id) as count_  from rental group by month_)
select * from m_count;


-- CTE for Pivot Operations
-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in
-- separate columns for different payment methods

-- there was no payment method column present so i added this column

alter table payment add column payment_method varchar(255);
select * from payment;

update payment set payment_method = 'credit_card' where customer_id in (select customer_id from customer where mod(customer_id,2) = 0); 
update payment set payment_method = 'cheque' where customer_id in (select customer_id from customer where mod(customer_id,3) = 0); 
update payment set payment_method = 'by_hand' where customer_id in (select customer_id from customer where mod(customer_id,7) = 0); 
update payment set payment_method = 'wire' where customer_id in (select customer_id from customer where mod(customer_id,5) = 0); 
update payment set payment_method = 'coupon' where payment_method is null ; 

with payment_methods as 
(select sum(case when payment_method = 'coupon' then 1 else 0 end) as coupon,
sum(case when payment_method = 'wire' then 1 else 0 end) as wire,
sum(case when payment_method = 'by_hand' then 1 else 0 end) as by_hand,
sum(case when payment_method = 'cheque' then 1 else 0 end) as cheque,
sum(case when payment_method = 'credit_card' then 1 else 0 end) as credit_card
from payment
)
select * from payment_methods;

-- CTE and Self-Join>
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together,
-- using the film_actor table
with actor_pairs as (
select f1.actor_id as actor1 , f2.actor_id as actor2 , f1.film_id from film_actor f1
 inner join film_actor f2 on f1.film_id = f2.film_id where f1.actor_id < f2.actor_id)
select * from actor_pairs;

-- CTE for Recursive Search>
-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager,
-- considering the reports_to column.

-- in the staff table there is no reports t0 column present 
-- so i created the reports to column in it
select * from staff;
alter table staff add column reports_to tinyint unsigned;
alter table staff add foreign key(reports_to) references staff(staff_id);
update staff set reports_to = 1 where staff_id = 2;

with recursive cte as (
select staff_id , 0 as level from staff where reports_to is null
union all 
select staff.staff_id, level+1 as level from staff inner join cte on cte.staff_id = staff.reports_to
)
select * from cte;



















